<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dodge The Block — MAX (SDS-ready)</title>
<style>
  :root{
    --bg:#041226; --card:#071428; --accent:#18c29c; --muted:#aab8c9;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  body{background:linear-gradient(180deg,#021226 0%, #031427 100%);color:#e6eef8;display:flex;flex-direction:column;align-items:center;}
  header{width:100%;max-width:980px;padding:18px 20px;box-sizing:border-box;display:flex;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:20px}
  .topRight{display:flex;gap:10px;align-items:center}
  .badge{background:rgba(0,0,0,0.3);padding:6px 10px;border-radius:10px;font-size:13px}
  main{width:100%;max-width:980px;padding:0 20px 36px;box-sizing:border-box}

  /* Canvas card */
  .card{background:rgba(3,14,30,0.6);border-radius:14px;padding:14px;box-shadow:0 8px 30px rgba(2,8,16,0.6);backdrop-filter:blur(4px)}
  #gameWrap{width:100%;height:calc(100vh - 220px);max-height:920px;display:flex;justify-content:center;align-items:center}
  canvas#game{width:360px;height:640px;border-radius:12px;display:block;background:transparent;box-shadow:inset 0 0 0 6px rgba(2,9,18,0.6);}

  /* HUD / Controls */
  .hud{display:flex;flex-wrap:wrap;gap:10px;margin-top:12px;align-items:center}
  .btn{background:var(--accent);color:#022425;padding:10px 14px;border-radius:999px;border:none;cursor:pointer;box-shadow:0 6px 18px rgba(10,40,35,0.2)}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .small{padding:6px 10px;font-size:13px}
  .stats{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  .stat{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px;font-size:13px;color:var(--muted)}

  /* Overlays */
  .overlay{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .modal{pointer-events:auto;background:linear-gradient(180deg, rgba(6,16,30,0.95), rgba(3,8,16,0.95));padding:18px;border-radius:12px;min-width:280px;max-width:560px;box-shadow:0 30px 90px rgba(0,0,0,0.6)}
  .hidden{display:none}

  /* menu content */
  .menuGrid{display:flex;gap:12px;flex-direction:column}
  label{font-size:13px;color:var(--muted)}
  input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(255,255,255,0.02);color:#e6eef8}
  .row{display:flex;gap:8px;align-items:center}

  /* loading */
  .loadingBox{background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  .muted{color:var(--muted);font-size:13px}

  footer{width:100%;max-width:980px;padding:12px 20px;color:var(--muted);box-sizing:border-box;font-size:13px}
  @media (min-width:900px){
    canvas#game{width:420px;height:760px}
    #gameWrap{height:760px}
  }
</style>
</head>
<body>
<header>
  <h1>Dodge The Block — MAX (SDS-ready)</h1>
  <div class="topRight">
    <div id="walletBadge" class="badge">Wallet: <span id="walletLabel">Not connected</span></div>
    <div id="sdsBadge" class="badge">SDS: <span id="sdsLabel">Disconnected</span></div>
    <button id="menuBtn" class="btn small">Menu</button>
  </div>
</header>

<main>
  <div id="gameCard" class="card">
    <div id="gameWrap">
      <canvas id="game" width="360" height="640"></canvas>
      <!-- Loading overlay -->
      <div id="loadingOverlay" style="position:absolute">
        <div class="loadingBox muted">Loading images... Preparing game assets. Please wait.</div>
      </div>
    </div>

    <div class="hud">
      <div style="flex:1">
        <div class="stats" id="statRow">
          <div class="stat" id="status">Status: Ready</div>
          <div class="stat">Level: <span id="level">1</span></div>
          <div class="stat">Time: <span id="levelTime">-</span></div>
          <div class="stat">Score: <span id="score">0</span></div>
          <div class="stat">Lives: <span id="lives">3</span></div>
          <div class="stat">Shild: <span id="shield">0</span></div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnRestart" class="btn small">Restart</button>
        <button id="btnPause" class="btn small">Pause</button>
        <button id="btnLeaderboard" class="btn small secondary">Leaderboard</button>
        <button id="btnConnect" class="btn small">Connect Wallet</button>
        <button id="btnSDS" class="btn small secondary">Connect SDS</button>
      </div>
    </div>
  </div>
</main>

<!-- MENU MODAL -->
<div id="menuModal" class="overlay hidden">
  <div class="modal">
    <h3>Menu</h3>
    <div class="menuGrid">
      <div><strong>How to play</strong>
        <p class="muted">Touch canvas to move (mobile). On PC use ←/→ or A/D. Avoid enemies (red/purple), collect Life (green) and Shield (gold).</p>
      </div>

      <div><strong>Profile</strong>
        <label>Your name</label>
        <input id="profileName" type="text" placeholder="Player name" />
        <div class="row">
          <button id="saveProfile" class="btn small">Save</button>
          <button id="closeMenu" class="btn small secondary">Close</button>
        </div>
      </div>

      <div><strong>Settings</strong>
        <label><input id="optSound" type="checkbox" checked /> Sound</label><br/>
        <label><input id="optVib" type="checkbox" /> Vibration (mobile)</label>
      </div>
    </div>
  </div>
</div>

<!-- Leaderboard modal -->
<div id="leaderModal" class="overlay hidden">
  <div class="modal">
    <h3>Leaderboard (local)</h3>
    <div id="leaderList" style="max-height:300px;overflow:auto"></div>
    <div style="margin-top:12px;text-align:right">
      <button id="closeLeader" class="btn small secondary">Close</button>
    </div>
  </div>
</div>

<footer>
  <div class="muted">Touch canvas to move (mobile). Power-ups use custom transparent sprites (no boxes). SDS-ready demo.</div>
</footer>

<script>
/*
  Complete game script (copy/paste).
  - Ensure assets/Bomb.png, assets/Life.png, assets/Shild.png exist (transparent PNG).
  - SDS integration: replace `connectSDS()` stub below with actual Somnia SDK usage (see docs).
*/

// ---------- CONFIG & STATE ----------
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const LANES = 4;
const MAX_ENEMIES = 12;
const POWERUP_CHANCE = 0.12;
const MAX_POWERUPS = 2;
const MIN_POWERUP_DIST = 120;

let player = { w:48, h:36, x:0, y:0, vx:0, maxSpeed:12, accel:1.8, friction:0.86, shield:0 };
let enemies=[], powerups=[], particles=[], stars=[];
let score=0, lives=3, running=true, levelIndex=0, levelTimer=0;
let spawnInterval = 900, fallbackTimer=0, lastFrame = Date.now();
let assets = { bomb:null, life:null, shild:null };
let assetsReady = false;
let sdsConnected = false;
let walletAddress = null;

// LEVELS (progressive)
const LEVELS = [
  {duration:18, spawnInterval:820, speedMul:1.0},
  {duration:20, spawnInterval:720, speedMul:1.18},
  {duration:24, spawnInterval:600, speedMul:1.35},
  {duration:28, spawnInterval:460, speedMul:1.6},
  {duration:9999, spawnInterval:380, speedMul:1.9}
];

// UI refs
const loadingOverlay = document.getElementById('loadingOverlay');
const levelEl = document.getElementById('level');
const levelTimeEl = document.getElementById('levelTime');
const statusEl = document.getElementById('status');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const shieldEl = document.getElementById('shield');
const walletLabel = document.getElementById('walletLabel');
const sdsLabel = document.getElementById('sdsLabel');

// ---------- UTIL ----------
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return min + Math.random()*(max-min); }

// ---------- RESIZE CANVAS ----------
function resizeCanvas(){
  const padH = 160;
  let W = Math.min(window.innerWidth - 40, 960);
  let H = Math.min(window.innerHeight - padH, 1000);
  if(window.innerWidth < 600) W = window.innerWidth - 36;
  canvas.width = Math.max(320, Math.round(W));
  canvas.height = Math.max(520, Math.round(H));
}
window.addEventListener('resize', ()=>{ resizeCanvas(); placePlayerBottom(); initStars(); });
resizeCanvas();

// ---------- PRELOAD ASSETS ----------
function loadImg(src){ return new Promise(res=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>{ console.warn('img load fail',src); res(null); }; i.src=src; }); }

async function preloadAll(){
  loadingOverlay.style.display = 'block';
  const base = 'assets/';
  const [bomb, life, shild] = await Promise.all([
    loadImg(base + 'Bomb.png'),
    loadImg(base + 'Life.png'),
    loadImg(base + 'Shild.png')
  ]);
  assets.bomb = bomb; assets.life = life; assets.shild = shild;
  assetsReady = true;
  loadingOverlay.style.display = 'none';
  resetGame();
}
preloadAll();

// ---------- STARS BACKGROUND ----------
function initStars(){ stars=[]; const n = Math.max(30, Math.round(canvas.width*0.04)); for(let i=0;i<n;i++) stars.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,r:Math.random()*1.6+0.6,alpha:0.08+Math.random()*0.8,speed:0.02+Math.random()*0.06}); }
initStars();

// ---------- LANES ----------
function computeLanes(){ const lanes=[]; const margin=30; const usable = canvas.width - margin*2; for(let i=0;i<LANES;i++) lanes.push(Math.round(margin + usable * (i + 0.5) / LANES)); return lanes; }

// ---------- LEVEL / RESET ----------
function setLevel(i){
  levelIndex = clamp(i, 0, LEVELS.length-1);
  spawnInterval = LEVELS[levelIndex].spawnInterval;
  levelTimer = LEVELS[levelIndex].duration * 1000;
  levelEl.textContent = levelIndex+1;
  levelTimeEl.textContent = Math.ceil(levelTimer/1000);
  statusEl.textContent = 'Status: Level ' + (levelIndex+1);
}

function placePlayerBottom(){
  player.x = Math.max(8, (canvas.width/2) - player.w/2);
  player.y = canvas.height - player.h - 18;
}
function resetGame(){
  resizeCanvas();
  placePlayerBottom();
  player.vx = 0; player.shield = 0;
  enemies=[]; powerups=[]; particles=[]; initStars();
  score = 0; lives = 3; running = true;
  scoreEl.textContent = score; livesEl.textContent = lives; shieldEl.textContent = player.shield;
  setLevel(0);
  spawnInterval = LEVELS[levelIndex].spawnInterval;
  fallbackTimer = 0;
  // spawn initial enemies but not immediate chaos
  for(let i=0;i<2;i++) spawnEnemy(true);
}

// ---------- SPAWN ENEMY (smarter, prefers player's lanes) ----------
let lastSpawnLane=-1, laneLastTime = new Array(LANES).fill(0);
function spawnEnemy(preferPlayer=false){
  if(enemies.length >= MAX_ENEMIES) return;
  const lanes = computeLanes();
  // pick lane: often near player
  let lane;
  if(preferPlayer && Math.random() < 0.9){
    // choose lane closest to player center but add jitter
    const px = player.x + player.w/2;
    let best = 0; let bestd = Infinity;
    for(let i=0;i<LANES;i++){ const d = Math.abs(px - lanes[i]); if(d < bestd){ best = i; bestd = d; } }
    // 50% choose nearest, otherwise random
    lane = (Math.random()<0.65) ? best : Math.floor(Math.random()*LANES);
  } else {
    lane = Math.floor(Math.random()*LANES);
  }

  // avoid same lane too often
  let tries=0;
  while(tries<8){
    const now = Date.now();
    if(lane !== lastSpawnLane && (now - laneLastTime[lane] > 300)) break;
    lane = Math.floor(Math.random()*LANES); tries++;
  }
  lastSpawnLane = lane; laneLastTime[lane] = Date.now();

  const laneX = lanes[lane];
  const jitter = (Math.random()-0.5) * Math.min(36, canvas.width*0.04);
  const x = clamp(laneX - 20 + jitter, 12, canvas.width - 48);
  const base = 2 + Math.random()*2.6;
  const speed = base * LEVELS[levelIndex].speedMul;
  const size = 22 + Math.random()*44;
  const r = Math.random();
  let type = 'red'; if(r<0.10) type='big'; else if(r<0.32) type='zig'; else if(r<0.48) type='home';
  enemies.push({lane, x, y:-size - Math.random()*120, w:size, h:size, speed, ay:0.01 + Math.random()*0.03, type, phase:Math.random()*Math.PI*2, oscAmp:6+Math.random()*24, oscSpeed:0.004+Math.random()*0.012, trail:[]});
}

// ---------- SPAWN POWERUP ----------
function spawnPowerupAt(x,y){
  if(powerups.length >= MAX_POWERUPS) return;
  for(const p of powerups){
    const dx = (p.x + p.w/2) - x; const dy = (p.y + p.h/2) - y;
    if(Math.sqrt(dx*dx + dy*dy) < MIN_POWERUP_DIST) return;
  }
  const types = ['shild','life','bomb','score'];
  const t = types[Math.floor(Math.random()*types.length)];
  const size = Math.floor(Math.max(40, Math.min(canvas.width*0.09, 64)));
  powerups.push({x:clamp(x - size/2, 8, canvas.width - size - 8), y, w:size, h:size, type:t, dy:1.6, created:Date.now()});
}

// fallback spawn routine
function fallbackStep(dt){
  fallbackTimer += dt;
  if(fallbackTimer > spawnInterval){
    fallbackTimer = 0;
    // prefer player lanes
    spawnEnemy(true);
    if(Math.random() < POWERUP_CHANCE){
      const lanes = computeLanes();
      const lx = lanes[Math.floor(Math.random()*lanes.length)];
      spawnPowerupAt(clamp(lx + (Math.random()-0.5)*40, 32, canvas.width-64), -28);
    }
    spawnInterval = Math.max(320, spawnInterval - 0.6); // gradually increase difficulty
  }
}

// ---------- TRAIL / PARTICLES ----------
function addTrail(e){ e.trail = e.trail||[]; const tsize = Math.max(6, Math.round(e.w/4)); e.trail.push({x:e.x + e.w/2, y:e.y + e.h/2, age:0, life:300, col:(e.type==='big'?'#9fb0ff': e.type==='zig'?'#c77bff': e.type==='home'?'#ffb86b':'#ff6b6b'), size:tsize}); if(e.trail.length>12) e.trail.shift(); }
function spawnParticles(x,y,col,count=10){ for(let i=0;i<count;i++) particles.push({x,y,vx:(Math.random()-0.5)*3, vy:(Math.random()-2.5)*-2, age:0, life:200+Math.random()*400, col}); }

// ---------- INPUT ----------
let touchTarget = null;
canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; touchTarget = t.clientX - canvas.getBoundingClientRect().left; e.preventDefault(); });
canvas.addEventListener('touchmove', e=>{ const t=e.touches[0]; touchTarget = t.clientX - canvas.getBoundingClientRect().left; e.preventDefault(); });
canvas.addEventListener('touchend', ()=> touchTarget = null);
let keys = {};
window.addEventListener('keydown', e=> keys[e.key] = true);
window.addEventListener('keyup', e=> keys[e.key] = false);

// apply input to player velocity
function applyInput(){
  if(touchTarget != null){
    const target = touchTarget - player.w/2;
    const diff = target - player.x;
    player.vx += diff * 0.048;
  } else {
    if(keys['ArrowLeft'] || keys['a']) player.vx -= player.accel * 1.2;
    else if(keys['ArrowRight'] || keys['d']) player.vx += player.accel * 1.2;
    else player.vx *= player.friction;
    if(Math.abs(player.vx) < 0.02) player.vx = 0;
  }
  player.vx = clamp(player.vx, -player.maxSpeed, player.maxSpeed);
  player.x += player.vx;
  if(player.x < 8){ player.x=8; player.vx=0; }
  if(player.x > canvas.width - player.w - 8){ player.x = canvas.width - player.w - 8; player.vx = 0; }
}

// ---------- COLLISIONS & POWERUPS ----------
function rectIntersect(a,b){
  const pad = 6;
  return !(a.x + a.w - pad < b.x || a.x > b.x + b.w - pad || a.y + a.h - pad < b.y || a.y > b.y + b.h - pad);
}

function onPlayerHit(e){
  if(player.shield>0){
    player.shield--; shieldEl.textContent = player.shield;
    spawnParticles(player.x+player.w/2, player.y+player.h/2, '#9be7ff', 18);
    return;
  }
  lives--; livesEl.textContent = lives;
  spawnParticles(player.x+player.w/2, player.y+player.h/2, '#ff6b6b', 26);
  if(lives<=0){ running=false; statusEl.textContent = 'GAME OVER'; saveScoreLocal(); }
  // notify SDS (if connected)
  if(sdsConnected && window.sdsPublishEvent) window.sdsPublishEvent({type:'player_hit', lives});
}

function applyPowerup(t){
  if(t==='shild'){ player.shield = Math.min(3, player.shield+1); shieldEl.textContent = player.shield; }
  else if(t==='life'){ lives = Math.min(5, lives+1); livesEl.textContent = lives; }
  else if(t==='bomb'){ enemies = enemies.filter(x=> x.type === 'big'); spawnParticles(canvas.width/2, canvas.height/2, '#ffd36b', 40); }
  else if(t==='score'){ score += 12; scoreEl.textContent = score; }
  // notify SDS
  if(sdsConnected && window.sdsPublishEvent) window.sdsPublishEvent({type:'powerup_taken', powerup:t, score, lives});
}

// ---------- UPDATE ----------
function update(dt){
  // stars
  for(const s of stars){ s.y += s.speed * dt * 0.02; if(s.y > canvas.height + 10) s.y = -10; }

  // enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e = enemies[i];
    const lanes = computeLanes();
    const targetX = clamp(lanes[e.lane] - e.w/2, 8, canvas.width - e.w - 8);
    e.x += (targetX - e.x) * 0.06 + Math.sin(e.phase*1.2) * 0.02 * (e.w*0.22);
    e.phase += e.oscSpeed * dt;
    const vOsc = Math.sin(e.phase) * e.oscAmp * 0.02;
    e.speed += e.ay * (dt/16);
    e.y += e.speed * (dt/16) + vOsc;
    if(Math.random() < 0.6) addTrail(e);
    if(e.trail) for(const t of e.trail) t.age += dt;
    if(rectIntersect(player, e) && running){ onPlayerHit(e); enemies.splice(i,1); continue; }
    if(e.y > canvas.height + 140){ enemies.splice(i,1); score++; scoreEl.textContent = score; }
  }

  // powerups
  for(let i=powerups.length-1;i>=0;i--){
    const p = powerups[i]; p.y += p.dy * (dt/16);
    if(rectIntersect(player, {x:p.x,y:p.y,w:p.w,h:p.h})){ applyPowerup(p.type); powerups.splice(i,1); continue; }
    if(p.y > canvas.height + 140) powerups.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const t = particles[i]; t.age += dt; t.x += t.vx * dt * 0.02; t.y += t.vy * dt * 0.02; if(t.age > t.life) particles.splice(i,1);
  }

  // level timer
  if(levelTimer > 0){ levelTimer -= dt; levelTimeEl.textContent = Math.max(0, Math.ceil(levelTimer/1000)); if(levelTimer <= 0){ const next = Math.min(levelIndex + 1, LEVELS.length-1); setLevel(next); score += 6; scoreEl.textContent = score; } }
}

// ---------- DRAW ----------
function drawBackground(){
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0,'#020215'); g.addColorStop(0.5,'#071028'); g.addColorStop(1,'#041226');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
  for(const s of stars){ ctx.globalAlpha = s.alpha * 0.9; ctx.fillStyle='#eaf6ff'; ctx.fillRect(s.x,s.y,s.r,s.r); }
  ctx.globalAlpha = 1;
}

function roundRect(x,y,w,h,r,fill,stroke){
  if(typeof r==='undefined') r=6; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

function draw(){
  drawBackground();

  // particles
  for(const p of particles){ const a = 1 - (p.age / p.life); ctx.globalAlpha = Math.max(0,a); ctx.fillStyle = p.col; ctx.fillRect(p.x, p.y, 3, 3); ctx.globalAlpha = 1; }

  // enemy trails
  for(const e of enemies){
    if(e.trail) for(const t of e.trail){
      const a = 1 - (t.age / t.life); if(a<=0) continue;
      ctx.save(); ctx.globalAlpha = Math.min(0.85, a*0.8); ctx.fillStyle=t.col; ctx.shadowBlur = Math.max(6, Math.round(e.w*0.6)); ctx.shadowColor = t.col;
      const w = t.size*1.6, h = t.size*1.6; roundRect(t.x - w/2, t.y - h/2, w, h, Math.max(4, t.size/4), true);
      ctx.restore();
    }
  }

  // enemies (glow blocks)
  for(const e of enemies){
    ctx.save(); ctx.shadowBlur = Math.max(12, Math.round(e.w*0.6));
    if(e.type==='big'){ ctx.fillStyle='#33f3c2'; ctx.shadowColor='#33f3c2'; }
    else if(e.type==='zig'){ ctx.fillStyle='#c377ff'; ctx.shadowColor='#c377ff'; }
    else if(e.type==='home'){ ctx.fillStyle='#ffb86b'; ctx.shadowColor='#ffb86b'; }
    else { ctx.fillStyle='#ff6b6b'; ctx.shadowColor='#ff6b6b'; }
    roundRect(e.x, e.y, e.w, e.h, Math.max(6, e.w/6), true);
    ctx.restore();
  }

  // powerups draw: actual image only, with shadow (no box)
  const now = Date.now();
  for(const p of powerups){
    const cx = p.x + p.w/2, cy = p.y + p.h/2;
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = Math.max(8, p.w * 0.34);
    let img = null;
    if(p.type === 'life') img = assets.life;
    else if(p.type === 'shild') img = assets.shild;
    else if(p.type === 'bomb') img = assets.bomb;
    else img = assets.shild;
    if(img){
      if(p.type === 'life'){
        const angle = Math.sin(now * 0.0025 + p.created*0.0006) * 0.24;
        ctx.translate(cx, cy); ctx.rotate(angle);
        const s = Math.min(canvas.width*0.12, p.w*1.06);
        ctx.drawImage(img, -s/2, -s/2, s, s);
      } else {
        const s = Math.min(canvas.width*0.11, p.w*1.05);
        ctx.drawImage(img, cx - s/2, cy - s/2, s, s);
      }
    }
    ctx.restore();
  }

  // player
  ctx.save();
  if(player.shield>0){ ctx.shadowBlur=28; ctx.shadowColor='#7fe8ff'; }
  else { ctx.shadowBlur=10; ctx.shadowColor='rgba(0,0,0,0.45)'; }
  ctx.fillStyle = '#55d0ff'; roundRect(player.x, player.y, player.w, player.h, 10, true);
  // subtle pseudo-3D highlight
  ctx.fillStyle = 'rgba(255,255,255,0.06)'; roundRect(player.x + 6, player.y + 4, player.w-12, player.h/2, 8, true);
  ctx.restore();

  // HUD text (top-left)
  ctx.fillStyle='#e6eef8'; ctx.font='14px sans-serif';
  ctx.fillText('Time Lvl: ' + Math.max(0, Math.round(levelTimer/1000)) + 's', 12, 20);
}

// ---------- MAIN LOOP ----------
function loop(){
  const now = Date.now();
  const dt = Math.min(60, now - lastFrame);
  lastFrame = now;
  if(assetsReady && running){
    applyInput();
    fallbackStep(dt);
    update(dt);
  }
  draw();
  requestAnimationFrame(loop);
}

// ---------- FALLBACK FUNCS for debug ----------
window.spawnEnemy = spawnEnemy;
window.spawnPowerupAt = spawnPowerupAt;
window.resetGame = resetGame;

// ---------- START after assets ready ----------
(function waitForAssets(){ if(!assetsReady){ setTimeout(waitForAssets, 80); return; } for(let i=0;i<2;i++) spawnEnemy(true); loop(); })();

// ---------- UI: buttons ----------
document.getElementById('btnPause').addEventListener('click', ()=>{
  running = !running;
  document.getElementById('btnPause').textContent = running ? 'Pause' : 'Resume';
  statusEl.textContent = running ? ('Status: Level ' + (levelIndex+1)) : 'Status: Paused';
});
document.getElementById('btnRestart').addEventListener('click', ()=>{ resetGame(); });
document.getElementById('menuBtn').addEventListener('click', ()=>{ document.getElementById('menuModal').classList.remove('hidden'); });
document.getElementById('closeMenu').addEventListener('click', ()=>{ document.getElementById('menuModal').classList.add('hidden'); });
document.getElementById('btnLeaderboard').addEventListener('click', ()=>{ showLeaderboard(); });
document.getElementById('closeLeader').addEventListener('click', ()=>{ document.getElementById('leaderModal').classList.add('hidden'); });
document.getElementById('saveProfile').addEventListener('click', ()=>{ localStorage.setItem('playerName', document.getElementById('profileName').value || 'Player'); alert('Saved'); });

// ---------- LEADERBOARD (local) ----------
function saveScoreLocal(){
  const name = localStorage.getItem('playerName') || 'Player';
  const scores = JSON.parse(localStorage.getItem('leader') || '[]');
  scores.push({name, score, date:Date.now()});
  scores.sort((a,b)=>b.score - a.score);
  localStorage.setItem('leader', JSON.stringify(scores.slice(0,30)));
}
function showLeaderboard(){
  const list = document.getElementById('leaderList'); list.innerHTML = '';
  const scores = JSON.parse(localStorage.getItem('leader') || '[]');
  if(scores.length === 0) list.innerHTML = '<div class="muted">No scores yet (local only).</div>';
  else scores.forEach((s,i)=>{ const d = new Date(s.date); list.innerHTML += `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.02)"><strong>${i+1}. ${s.name}</strong> — ${s.score} <div class="muted" style="font-size:12px">${d.toLocaleString()}</div></div>`; });
  document.getElementById('leaderModal').classList.remove('hidden');
}

// ---------- WALLET (simple Metamask connect) ----------
async function connectWallet(){
  if(window.ethereum){
    try{
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      walletAddress = accounts[0];
      walletLabel.textContent = walletAddress.slice(0,6) + '...' + walletAddress.slice(-4);
      // optionally sign or do other web3 init
    }catch(err){ console.warn('wallet connect err', err); alert('Wallet connect cancelled'); }
  }else{
    alert('No Ethereum wallet detected (use MetaMask).');
  }
}
document.getElementById('btnConnect').addEventListener('click', connectWallet);

// ---------- SDS (stub) ----------
/*
  This is a stub for Somnia Data Streams integration.
  Replace connectSDS() with actual SDK code following somnia docs:

  Example (pseudo):
    import { createPublicClient, SDK } from '@somnia-chain/streams';
    const publicClient = createPublicClient({ chain: defineChain(...), transport: http() });
    const sdk = new SDK({ public: publicClient });
    const subscription = await sdk.streams.subscribe({ eventIds: ['your-event'] }, (data)=>{ ... });

  For hackathon: you will likely need to deploy an on-chain contract that emits events,
  or register publisher access. Ask Somnia team in their Discord to whitelist publisher if needed.

  In this template we create a small interface:
    - connectSDS(): toggles sdsConnected and registers stub window.sdsPublishEvent
    - window.sdsPublishEvent(obj): will console.log and (if real) should emit to stream
*/
function connectSDS(){
  if(sdsConnected){
    sdsConnected = false; sdsLabel.textContent = 'Disconnected';
    window.sdsPublishEvent = null;
    alert('SDS disconnected (stub). Replace with real SDK to connect.');
    return;
  }
  // stub connect
  sdsConnected = true; sdsLabel.textContent = 'Connected (stub)';
  // example publish function (replace with SDK emit)
  window.sdsPublishEvent = (payload) => {
    console.log('SDS publish (stub):', payload);
    // TODO: replace with sdk.streams.setAndEmitEvents(...) using somnia SDK
  };
  alert('SDS connected (stub). Replace with Somnia SDK for real streaming.');
}
document.getElementById('btnSDS').addEventListener('click', connectSDS);

// ---------- EXTRAS: convenience spawner for debug ----------
window.spawnPowerupRandom = function(){
  const lanes = computeLanes();
  spawnPowerupAt(lanes[Math.floor(Math.random()*lanes.length)], -20);
};

// ---------- INITIAL UI state ----------
document.getElementById('profileName').value = localStorage.getItem('playerName') || '';
walletLabel.textContent = 'Not connected';
sdsLabel.textContent = 'Disconnected';

// ---------- END OF SCRIPT ----------
</script>
</body>
</html>
